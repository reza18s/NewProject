// File: src/app.ts
import express, { NextFunction, Request, Response } from "express";
import { configDotenv } from "dotenv";
import userRouter from "./routes/userRoutes";
import { globalErrorHandler } from "./controllers/errorController";
import { ErrorHandler } from "./utils/ErrorHandler";
import profilesRouter from "./routes/profileRoutes";
import cors from "cors";

const app = express();
const allowedOrigins = ["http://localhost:3000", "http://localhost:3001"];
const corsOptions = {
  origin: (origin: string | undefined, callback: any) => {
    if (!origin) return callback(null, true); // Allow no-origin requests
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      callback(new Error("Not allowed by CORS"));
    }
  },
  credentials: true, // Allow credentials like cookies, authorization headers, etc.
};
// Middleware
app.use(cors(corsOptions));
app.use(express.urlencoded({ extended: true }));

app.use(express.json());

configDotenv({ path: "./config.env" });
app.use(express.static(`${__dirname}/public`));

// // // 3) ROUTES
app.use("/api/v1/users", userRouter);
app.use("/api/v1/profiles", profilesRouter);
app.get("/", (req: Request, res: Response) => {
  res.status(200).json({ stats: "s" });
});
app.all("*", (req: Request, res: Response, next: NextFunction) => {
  next(new ErrorHandler(`Can't find ${req.originalUrl} on this server!`, 404));
});
// 4) START SERVER
const port = process.env.PORT || 3000;
app.use(globalErrorHandler);
app.listen(port, () => {
  // eslint-disable-next-line no-console
  console.log(`App running on port ${port}...`);
});

// File: src/utils/ErrorHandler.ts
export class ErrorHandler extends Error {
  statusCode?: number;
  status?: string;
  isOperational?: boolean;
  constructor(message: string, statusCode: number) {
    super(message);
    this.statusCode = statusCode;
    this.status = `${statusCode}`.startsWith("4") ? "fail" : "error";
    this.isOperational = true;

    Error.captureStackTrace(this, this.constructor);
  }
}

// File: src/utils/db.ts
import { PrismaClient } from "@prisma/client";

declare global {
  // eslint-disable-next-line no-var, no-unused-vars
  var prisma: PrismaClient | undefined;
}

export const db = globalThis.prisma || new PrismaClient();

if (process.env.NODE_ENV !== "production") {
  globalThis.prisma = db;
}

// File: src/utils/catchAsync.ts
import { NextFunction, Request, Response } from "express";

export const catchAsync = (
  fn: (req: Request, res: Response, next: NextFunction) => Promise<void>,
) => {
  return (req: Request, res: Response, next: NextFunction) =>
    fn(req, res, next).catch(next);
};

// File: src/types/index.ts
// Generated by https://quicktype.io
import { Users } from "@prisma/client";
import { Request } from "express";

// Generated by https://quicktype.io

export interface IUser {
  _id: string;
  name: string;
  email: string;
  role: Role;
  active: boolean;
  avatar: string;
  password: string;
  passwordConfirm: string;
  passwordChangedAt: string;
  passwordRestToken: string;
  passwordRestExpires: string;
}

export enum Role {
  Admin = "admin",
  User = "user",
}

// Generated by https://quicktype.io
export interface IDecoded {
  id: string;
  phoneNumber: string;
  iat: number;
  exp: number;
}
export interface IRequest extends Request {
  user: Users;
}
export interface IError extends Error {
  name: string;
  code?: number;
  statusCode?: number;
  stringValue?: string;
  kind?: string;
  status?: string;
  path?: string;
  value?: string;
  errmsg?: string;
  isOperational?: boolean;
}

// File: src/controllers/errorController.ts
import { NextFunction, Request, Response } from "express";
import { IError } from "../types";

const sendErrorDev = (err: IError, res: Response) => {
  res.status(err.statusCode).json({
    status: err.status,
    error: err,
    message: err.message,
    stack: err.stack,
  });
};

const sendErrorProd = (err: IError, res: Response) => {
  if (err.isOperational) {
    res.status(err.statusCode).json({
      status: err.status,
      message: err.message,
    });
  } else {
    res.status(500).json({
      status: "error",
      message: "Something went very wrong!",
    });
  }
};

export const globalErrorHandler = (
  err: IError,
  req: Request,
  res: Response,
  next: NextFunction,
) => {
  err.statusCode = err.statusCode || 500;
  err.status = err.status || "error";
  if (process.env.NODE_ENV === "development") {
    sendErrorDev(err, res);
  } else if (process.env.NODE_ENV === "production") {
    const error = err;
    sendErrorProd(error, res);
  }
};

// File: src/controllers/userController.ts
import { Response, NextFunction } from "express";
import { catchAsync } from "../utils/catchAsync";
import { ErrorHandler } from "../utils/ErrorHandler";
import { IRequest } from "../types";
import { db } from "../utils/db";
import { getAll, getOne } from "./handelFactory";

// const filterObj = (obj, ...allowedFields: string[]): object => {
//   const newObj = {};
//   Object.keys(obj).forEach(
//     (el) => allowedFields.includes(el) && (newObj[el] = obj[el]),
//   );
//   return newObj;
// };

// export const updateMyUser = catchAsync(
//   async (req: IRequest, res: Response, next: NextFunction) => {
//     if (req.body.password || req.body.passwordConfirm) {
//       return next(
//         new ErrorHandler(
//           "This route is not for password updates. Please use /updateMyPassword.",
//           400,
//         ),
//       );
//     }
//     const filterReq = filterObj(req.body, "name", "email");

//     const currentUser = await User.findByIdAndUpdate(req.user._id, filterReq, {
//       new: true,
//       runValidators: true,
//     });

//     res.status(201).json({
//       status: "success",
//       data: {
//         user: currentUser,
//       },
//     });
//   },
// );

// export const DelMyUser = catchAsync(
//   async (req: IRequest, res: Response, next: NextFunction) => {
//     await User.findByIdAndUpdate(req.user._id, { active: false });
//     res.status(204).json({
//       status: "success",
//       data: {
//         user: null,
//       },
//     });
//   },
// );
export const getMe = (req: IRequest, res: Response, next: NextFunction) => {
  req.params.id = req.user.id;
  next();
};
export const getUsers = getAll(db.users);
export const getUser = getOne(db.users);
// export const updateUser = updateOne(User);
// export const deleteUser = delOne(User);

// File: src/controllers/profileController.ts
import { NextFunction, Request, Response } from "express";
import { db } from "../utils/db";
import { catchAsync } from "../utils/catchAsync";
import { createProfileObject, updateProfileObject } from "../validator";
import { IRequest } from "../types";
import { ErrorHandler } from "../utils/ErrorHandler";

export const getProfiles = catchAsync(async (req: Request, res: Response) => {
  const searchParams = req.query;
  const query = [
    { name: "category", value: "category" },
    { name: "search", value: "title", op: true },
  ];

  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  const searchObj: { [key: string]: any } = {};
  query.map((el) => {
    if (searchParams[el.name]) {
      searchObj[el.value] = el.op
        ? { contains: searchParams[el.name] }
        : searchParams[el.name];
    }
  });
  const profiles = await db.profiles.findMany({
    where: searchObj,
  });
  res.status(200).json({
    data: profiles,
  });
});
export const getProfile = catchAsync(async (req: Request, res: Response) => {
  const id = req.params.id;
  const profiles = await db.profiles.findUnique({
    where: { id },
  });
  res.status(200).json({
    data: profiles,
  });
});
export const createProfile = catchAsync(
  async (req: IRequest, res: Response, next: NextFunction) => {
    console.log(req.body);
    const {
      title,
      description,
      location,
      phone,
      realState,
      price,
      constructionDate,
      category,
      province,
      city,
      amenities,
      rules,
      tag,
    } = createProfileObject.parse(req.body);

    const user = await db.users.findUnique({
      where: { phoneNumber: req.user.phoneNumber },
    });
    if (!user) {
      return next(new ErrorHandler("حساب کاربری یافت نشد", 404));
    }
    console.log("fuckjk");

    const profile = await db.profiles.create({
      data: {
        title,
        description,
        location,
        phone,
        realState,
        constructionDate: new Date(constructionDate),
        amenities,
        rules,
        province,
        city,
        tag,
        category,
        price,
        userId: user.id,
      },
    });
    res.status(201).json({ message: "آگهی جدید اضافه شد", data: profile });
  },
);
export const updateProfile = catchAsync(
  async (req: IRequest, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const data = updateProfileObject.parse(req.body);

    const profile = await db.profiles.update({
      where: { id, userId: req.user.id },
      data: { ...data },
    });
    res.status(200).json({ data: profile });
  },
);
export const removeProfile = catchAsync(
  async (req: IRequest, res: Response, next: NextFunction) => {
    const { id } = req.params;
    const profile = await db.profiles.delete({
      where: { id, userId: req.user.id },
    });
    res.status(200).json({ message: "آگهی حذف شد", data: null });
  },
);

// File: src/controllers/handelFactory.ts
import { NextFunction, Request, Response } from "express";
import { IRequest } from "../types";
import { catchAsync } from "../utils/catchAsync";
import { ErrorHandler } from "../utils/ErrorHandler";
import { Prisma } from "@prisma/client";
import { DefaultArgs } from "@prisma/client/runtime/library";

export const getAll = (model: Prisma.UsersDelegate<DefaultArgs>) =>
  catchAsync(async (req: Request, res: Response) => {
    let filter: object = {};
    if (req.params.tourId) filter = { tour: req.params.tourId };
    const doc = await model.findMany({});
    res.status(200).json({
      status: "success",
      results: doc.length,
      data: {
        doc,
      },
    });
  });

export const getOne = (model: Prisma.UsersDelegate<DefaultArgs>, popOption?) =>
  catchAsync(async (req: Request, res: Response, next: NextFunction) => {
    let query;
    if (popOption) {
      query = model.findUnique({ where: { id: req.params.id } });
    } else {
      query = model.findUnique({ where: { id: req.params.id } });
    }
    const doc = await query;

    if (!doc) {
      return next(new ErrorHandler("no document found with this ID", 404));
    }
    res.status(200).json({
      status: "success",
      data: doc,
    });
  });
// export const createOne = (model: IModel) =>
//   catchAsync(async (req: Request, res: Response) => {
//     const doc: IUserDocument = await model.create(req.body);
//     res.status(201).json({
//       status: "success",
//       data: {
//         doc,
//       },
//     });
//   });
// export const updateOne = (model: IModel) =>
//   catchAsync(async (req: IRequest, res: Response, next: NextFunction) => {
//     const docId: string = req.params.id;
//     const doc = await model.findByIdAndUpdate(docId, req.body, {
//       new: true,
//     });
//     if (!doc) {
//       return next(new ErrorHandler("no document found with this ID", 404));
//     }
//     res.status(201).json({
//       status: "success",

//       data: {
//         doc,
//       },
//     });
//   });
// export const delOne = (model: IModel) =>
//   catchAsync(async (req: IRequest, res: Response, next: NextFunction) => {
//     const docID: string = req.params.id;
//     await model.findByIdAndDelete(docID);

//     res.status(201).json({
//       status: "success",
//       data: null,
//     });
//   });

// File: src/controllers/authController.ts
import { NextFunction, Request, Response } from "express";
import { catchAsync } from "../utils/catchAsync";
import { sign, verify } from "jsonwebtoken";
import { signinObject, signupObject } from "../validator";
import { db } from "../utils/db";
import { Users } from "@prisma/client";
import { ErrorHandler } from "../utils/ErrorHandler";
import { IDecoded, IRequest } from "../types";
export const createToken = (res: Response, statusCode: number, user: Users) => {
  try {
    const token = sign(
      { id: user.id, phoneNumber: user.phoneNumber },
      process.env.JWT_SECRET,
      {
        expiresIn: process.env.JWT_EXPIRES_IN,
      },
    );
    res.cookie("jwt", token, {
      httpOnly: true,
      secure: process.env.NODE_ENV != "development",
      expires: new Date(
        Date.now() + +process.env.COOKIES_EXPIRES * 24 * 60 * 60 * 1000,
      ),
    });

    res.status(statusCode).json({
      status: "success",
      token,
      data: {
        user,
      },
    });
  } catch (error) {
    console.log(error);
    res.status(400).json({
      status: "failed",
    });
  }
};

export const signup = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { phoneNumber } = signupObject.parse(req.body);

    const existingUser = await db.users.findUnique({
      where: { phoneNumber },
    });

    if (existingUser) {
      return next(new ErrorHandler("this user is already exists", 400));
    }

    const user = await db.users.create({
      data: {
        phoneNumber: phoneNumber,
      },
    });
    createToken(res, 201, user);
  },
);
export const signin = catchAsync(
  async (req: Request, res: Response, next: NextFunction) => {
    const { phoneNumber } = signinObject.parse(req.body);

    if (!phoneNumber) {
      return next(new ErrorHandler("please inter your phoneNumber", 400));
    }
    const user = await db.users.findUnique({
      where: { phoneNumber },
    });
    if (!user) {
      return next(new ErrorHandler("user does not exist", 400));
    }
    console.log(user);
    //create Express Password Checker
    createToken(res, 201, user);
  },
);
export const protect = catchAsync(
  async (req: IRequest, res: Response, next: NextFunction) => {
    let token: string;
    if (
      req.headers.authorization &&
      req.headers.authorization.startsWith("Bearer")
    ) {
      token = req.headers.authorization.split(" ")[1];
    }
    if (!token && req.headers.cookie) {
      token = req.headers.cookie.split("=")[1];
      console.log(token);
    }
    if (!token) {
      return next(
        new ErrorHandler(
          "Your not logged in! please log in to get access ",
          400,
        ),
      );
    }
    // @ts-expect-error
    const decoded: IDecoded = verify(token, process.env.JWT_SECRET);
    const currentUser = await db.users.findUnique({
      where: { id: decoded.id },
    });

    if (!currentUser) {
      return next(
        new ErrorHandler(
          "The user belonging to this token does no longer exist",
          400,
        ),
      );
    }
    req.user = currentUser;
    next();
  },
);

// File: src/validator/index.ts
import { z } from "zod";

export const signupObject = z
  .object({
    phoneNumber: z.string().regex(/^(?:0?|0980)?(9\d{9})$/),
  })
  .strict();
export const signinObject = z
  .object({
    phoneNumber: z.string().regex(/^(?:0?|0980)?(9\d{9})$/),
  })
  .strict();
export const forgotPasswordObject = z
  .object({
    email: z.string().email(),
  })
  .strict();
export const updatePasswordObject = z
  .object({
    password: z
      .string()
      .regex(/^(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,16}$/),
    newPassword: z
      .string()
      .regex(/^(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,16}$/),
    newPasswordConfirm: z
      .string()
      .regex(/^(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,16}$/),
  })
  .strict();
export const resetPasswordObject = z
  .object({
    password: z
      .string()
      .regex(/^(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,16}$/),
    passwordConfirm: z
      .string()
      .regex(/^(?=.*[a-z])(?=.*\d)(?=.*[!@#$%^&*])[A-Za-z\d!@#$%^&*]{8,16}$/),
  })
  .strict();
export const updateMyUserObject = z
  .object({
    name: z.string().min(4, "Please enter a valid value").optional(),
    avatar: z.string().url("please enter a url").optional(),
  })
  .strict();
export const updateUserObject = z
  .object({
    name: z.string().min(4, "Please enter a valid value").optional(),
    role: z.enum(["user", "admin"]).optional(),
    avatar: z.string().url("please enter a url").optional(),
  })
  .strict();
export const RealEstateCategorySchema = z.enum([
  "فروش",
  "رهن و اجاره",
  "اجاره بلند مدت",
  "اجاره کوتاه مدت",
  "نیاز به خرید",
  "مشارکت",
  "پیش فروش",
]);
export const createProfileObject = z.object({
  title: z.string(),
  description: z.string(),
  location: z.string(),
  phone: z.string(),
  realState: z.string(),
  price: z.number(),
  constructionDate: z.string(),
  category: z.string(),
  tag: z.string(),
  province: z.string(),
  city: z.string(),
  amenities: z.string(),
  rules: z.string(),
});
export const updateProfileObject = createProfileObject.extend({
  id: z.string(),
});

// File: src/routes/userRoutes.ts
import express from "express";
import { protect, signin, signup } from "../controllers/authController";
import { getMe, getUser, getUsers } from "../controllers/userController";

const userRouter = express.Router();

userRouter.get("/", getUsers);
userRouter.post("/signup", signup);
userRouter.post("/signin", signin);
// userRouter.patch("/update-password", protect, updatePassword);
// userRouter.patch("/update-me", protect, updateMyUser);
// userRouter.delete("/delete-me", protect, DelMyUser);
userRouter.get("/get-me", protect, getMe, getUser);
// userRouter.post("/forgotpassword", forgotPassword);
// userRouter.patch("/resetpassword/:token", resetPassword);

// userRouter
//    .route("/:id")
//    .patch(protect, restrictTo(Role.Admin), updateUser)
//    .delete(protect, restrictTo(Role.Admin), deleteUser)
//    .get(protect, restrictTo(Role.Admin), getUser);

export default userRouter;

// File: src/routes/profileRoutes.ts
import express from "express";
import {
  createProfile,
  getProfile,
  getProfiles,
  removeProfile,
  updateProfile,
} from "../controllers/profileController";
import { protect } from "../controllers/authController";

const profilesRouter = express.Router();

profilesRouter.get("/", getProfiles);
profilesRouter.get("/:id", getProfile);
profilesRouter.post("/", protect, createProfile);
profilesRouter.patch("/:id", protect, updateProfile);
profilesRouter.delete("/:id", protect, removeProfile);

export default profilesRouter;

// File: prisma/schema.prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider     = "mysql"
  url          = env("DATABASE_URL") // uses connection pooling
  directUrl    = env("DATABASE_URL") // uses a direct connection
  relationMode = "prisma"
}

enum Role {
  ADMIN_OWNER
  ADMIN
  USER
  GUEST
}

model Users {
  id          String     @id @default(cuid())
  name        String?
  avatarUrl   String?
  phoneNumber String     @unique
  email       String?
  createdAt   DateTime   @default(now())
  updatedAt   DateTime   @updatedAt
  role        Role       @default(USER)
  Profile     Profiles[]

  // Index on unique fields is redundant, so removing the explicit index here
}

enum Category {
  SALE // فروش
  MORTGAGE_AND_RENT // رهن و اجاره
  LONG_TERM_RENT // اجاره بلند مدت
  SHORT_TERM_RENT // اجاره کوتاه مدت
  NEED_TO_BUY // نیاز به خرید
  PARTNERSHIP // مشارکت
  PRE_SALE // پیش فروش
}

enum Tag {
  RESIDENTIAL_APARTMENT // آپارتمان مسکونی
  VILLA // خانه و ویلا
  LAND // زمین و کلنگی
  OFFICE // دفاتر اداری
  SHOP // مغازه و تجاری
  BUILDING_COMPLEX // مستغلات یکجا
  WAREHOUSE_FACTORY // کارخانه و انبار
  MINE // انواع معدن
  GOVERNMENT_CENTER // مراکز دولتی
  FARM_GREEN_SPACE // کشاورزی و فضای سبز
  EDUCATION_RECREATION // مراکز آموزشی،تفریحی
  MEDICAL_CENTER // مراکز بهداشتی و درمانی
  SHOP_AND_BOOTH // مغازه و غرفه
  APARTMENT_AND_SUITE // آپارتمان و سویت
  BEACH_VILLA // ویلا ساحلی
  FOREST_MOUNTAIN_VILLA // ویلا جنگلی-کوهستانی
  SWISS_COTTAGE // کلبه سوئیسی
  TOURISM // بومگردی
  LUXURY_ACCOMMODATION // اقامتگاه لاکچری
  EVENT_HALL // تالار و سالن مراسم
  OFFICE_APARTMENT // آپارتمان اداری
  SHOP_AND_COMMERCIAL // مغازه و تجاری
  GOVERNMENT_PROJECT // پروژه های دولتی
  MASKAN_MEHR_PROJECT // پروژه های مسکن مهر
  RESIDENTIAL_CONSTRUCTION // مشارکت در ساخت (مسکونی)
  COMMERCIAL_CONSTRUCTION // مشارکت در ساخت (اداری و تجاری)
  VILLA_CITY_CONSTRUCTION // مشارکت در ساخت (ویلا سازی و شهرک سازی)
  CONTRACT_MANAGEMENT // مدیریت پیمان و مشاوره
  LARGE_GOVERNMENT_PROJECT // پروژه های بزرگ دولتی
  LAND_AND_OLD_PROPERTY // زمین و کلنگی
}

model Profiles {
  id               String   @id @default(cuid())
  title            String
  description      String
  location         String
  phone            String
  realState        String
  price            Int
  constructionDate DateTime
  category         String
  tag              String
  province         String
  city             String
  amenities        String
  rules            String
  published        Boolean? @default(false)
  imagePath        String?
  userId           String
  user             Users    @relation(fields: [userId], references: [id]) // Renamed to user for better clarity
  createdAt        DateTime @default(now())
  updatedAt        DateTime @updatedAt

  @@index([userId])
}

